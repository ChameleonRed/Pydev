'''An helper file for the pydev debugger (REPL) console
'''
from code import InteractiveConsole
import sys
import traceback

import _pydev_completer
from pydevd_tracing import GetExceptionTracebackStr
from pydevd_vars import makeValidXmlValue

CONSOLE_OUTPUT = "output"
CONSOLE_ERROR  = "error"

class StdMessage:
    """Store the messages(error/output) generated by the interactive console
    """
    def __init__(self):
        self.message_list = []

    def write(self, line):
        """all calls to sys.stdout.write and sys.stderr.write 
        will be redirected here
        """
        self.message_list.append(line)

    def get_messages(self):
        """return all messages generated by the interactive console
        """
        message_list = self.message_list
        self.message_list = []
        return message_list


class ConsoleMessage:
    """Console Messages
    """
    def __init__(self):
        self.more = False
        # List of tuple [('error', 'error_message'), ('message_list', 'output_message')]
        self.console_messages = []
    
    def add_console_message(self, message_type, message):
        """add messages in the console_messages list 
        """
        for m in message.split("\n"):
            if m.strip():
                self.console_messages.append((message_type, m))

    def update_more(self, more):
        """more is set to true if further input is required from the user
        else more is set to false
        """
        self.more = more

    def toXML(self):
        """Create an XML for console message_list, error and more (true/false)
        <xml>
            <message_list>console message_list</message_list>
            <error>console error</error>
            <more>true/false</more>
        </xml>
        """
        def makeValid(s):
            return makeValidXmlValue(s)
        
        xml = '<xml><more>%s</more>' %(self.more)

        for message_type, message in self.console_messages:
            xml += '<%s message="%s"></%s>'%(message_type, makeValid(message), message_type)

        xml += '</xml>'
        
        return xml


class DebugConsole(InteractiveConsole):
    """Wrapper around code.InteractiveConsole, in order to send 
    errors and outputs to the debug console
    """
    def __init__(self, locals, thread_id, frame_id):
        """Initialize the DebugConsole
        creates a new instance of StdMessage which will be used as stdout and stderr hooks 
        """
        InteractiveConsole.__init__(self, locals)
        self.new_stdout = StdMessage()
        self.new_stderr = StdMessage()
        self.thread_id = thread_id
        self.frame_id = frame_id

    def push(self, line):
        """Change built-in stdout and stderr methods by the 
        new custom StdMessage.
        execute the InteractiveConsole.push.
        Change the stdout and stderr back be the original built-ins
        
        Return boolean (True if more input is required else False), 
        output_messages and input_messages
        """
        more = False
        original_stdout = sys.stdout
        original_stderr = sys.stderr
        output_messages = []
        error_messages = []
        try:
            try:
                sys.stdout = self.new_stdout
                sys.stderr = self.new_stderr 
                more = InteractiveConsole.push(self, line)
                output_messages = self.new_stdout.get_messages()
                error_messages = self.new_stderr.get_messages()
            except Exception:
                exc = GetExceptionTracebackStr()
                error_messages = ["Internal Error: %s"%(exc)]
        finally:
            if sys.stdout == self.new_stdout:
                sys.stdout = original_stdout
            if sys.stderr == self.new_stderr:
                sys.stderr = original_stderr            

        return more, output_messages, error_messages

    def update_locals(self, locals):
        """Update the locals of InteractiveConsole
        """
        self.locals = locals

    def update_frame_id(self, frame_id):
        """Update the frame id associated with the InteractiveConsole
        """
        self.frame_id = frame_id
    
    def update_thread_id(self, thread_id):
        """Update the thread_id associated with the InteractiveConsole
        """
        self.thread_id = thread_id


interactive_console = None

def update_interactive_console(interpreter):
    """add new interpreter in the debug_console_map
    """
    global interactive_console
    interactive_console = interpreter


def get_interactive_console():
    """returns the global interactive console.
    interactive console should have been initialized by this time 
    """
    return interactive_console


def clear_interactive_console():
    """set global InteractiveConsole to None
    """
    global interactive_console
    interactive_console = None


def create_interactive_console(frame, thread_id, frame_id):
    """Creates an interactive console for the received frame
    """
    console_message = ConsoleMessage()
    try:
        interpreter = DebugConsole(frame.f_locals, thread_id, frame_id)
        update_interactive_console(interpreter)
        console_message.add_console_message(CONSOLE_OUTPUT, "Connected to interactive console for selected frame")
        add_stacktrace_details(frame, console_message, init_message="[Current context]")
    except Exception:
        exc = GetExceptionTracebackStr()
        console_message.add_console_message(CONSOLE_ERROR, "Internal Error: Unable to initialize the interactive console" + exc)
        
    return console_message


def execute_console_command(frame, thread_id, frame_id, line):
    """fetch an interactive console instance from the cache and 
    push the received command to the console.
    
    create and return an instance of console_message 
    """
    output_messages = []
    error_messages = []
    console_message = ConsoleMessage()
   
    interpreter = get_interactive_console()
    if interpreter != None:
        if(interpreter.thread_id != thread_id or interpreter.frame_id != frame_id):
            # Context changed, update the InteractiveConsole locals
            interpreter.update_locals(frame.f_locals)
            interpreter.update_frame_id(frame_id)
            interpreter.update_thread_id(thread_id)
            add_stacktrace_details(frame, console_message, init_message="[Context changed]")
    else:
        # No console exists, possibly a new debug server get started
        create_interactive_console(frame, thread_id, frame_id)
        interpreter = get_interactive_console()
        add_stacktrace_details(frame, console_message, init_message="[Console reinitialized. Current context]")

    more, output_messages, error_messages = interpreter.push(line)
    console_message.update_more(more);
    for message in output_messages:
        console_message.add_console_message(CONSOLE_OUTPUT, message)
    for message in error_messages:
        console_message.add_console_message(CONSOLE_ERROR, message)

    return console_message


def get_completions(frame, act_tok):
    """ fetch all completions, create xml for the same
    return the completions xml
    """
    msg = ""
    if frame is not None:
        completer = _pydev_completer.Completer(get_frame_variables(frame), None)
        completions = completer.complete(act_tok) #return list of tuple(name, description, parameters, type)

        msg = "<xml>"

        for name, description, parameters, comp_type in completions:
            msg += '<comp p0="%s" p1="%s" p2="%s" p3="%s"/>' % (makeValidXmlValue(name), makeValidXmlValue(description), makeValidXmlValue(parameters), makeValidXmlValue(comp_type),)
        msg += "</xml>"

    return msg


def add_stacktrace_details(frame, console_message, init_message=""):
    """fetch and reverse the stacktrace for the provided frame.
    Update the details in the console_message
    """
    console_stacktrace = traceback.extract_stack(frame)
    console_stacktrace.reverse()
    if console_stacktrace:
        current_context = console_stacktrace[0] # top entry from stacktrace
        context_message = 'File "%s", line %s, in %s'%(current_context[0], current_context[1], current_context[2])
        console_message.add_console_message(CONSOLE_OUTPUT, "%s: %s"%(init_message, context_message))


def get_frame_variables(frame):
    """Create and return the new dictionary which contains frame locals and frame globals
    """
    updated_globals = {}
    if frame is not None:
        updated_globals.update(frame.f_globals)
        updated_globals.update(frame.f_locals) #locals later because it has precedence over the actual globals
    return updated_globals
